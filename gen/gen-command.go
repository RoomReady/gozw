package gen

import (
	"io"
	"strconv"
)

func writeStrings(w io.Writer, strings ...string) (int, error) {
	n := 0
	for _, s := range strings {
		sn, err := io.WriteString(w, s)
		n += sn
		if err != nil {
			return n, err
		}
	}
	return n, nil
}

// GenerateCommand ...
func (g *Generator) GenerateCommand(w io.Writer, cc CommandClass, cmd Command) (err error) {
	structName := cmd.GetStructName(cc)

	// if len(cmd.Params) -> errors
	// cmd.Params[#].Type has BIT_24, WORD, or DWORD

	_, err = writeStrings(w,
		"// THIS FILE IS AUTO-GENERATED BY ZWGEN\n",
		"// DO NOT MODIFY\n\n",
		"package ", cc.GetPackageName(), "\n\n",
		"import (\n",
	)
	if err != nil {
		return
	}
	var imports []string
	if len(cmd.Params) > 0 {
	ParamCheck:
		for _, p := range cmd.Params {
			switch p.Type {
			case "DWORD", "BIT_24", "WORD":
				imports = append(imports, "\t\"encoding/binary\"\n")
				break ParamCheck
			}
		}
		imports = append(imports,
			"\t\"encoding/gob\"\n",
			"\t\"errors\"\n",
		)
	} else {
		imports = append(imports, "\t\"encoding/gob\"\n")
	}
	imports = append(imports,
		"\n",
		"\t\"github.com/gozwave/gozw/cc\"\n",
	)
	_, err = writeStrings(w, imports...)
	if err != nil {
		return
	}
	_, err = writeStrings(w,
		")\n\n",
		"const Command", structName, " cc.CommandID = ", cmd.Key, "\n\n",
		"func init() {\n",
		"\tgob.Register(", structName, "{})\n",
		"\tcc.Register(cc.CommandIdentifier{\n",
		"\t\tCommandClass: cc.CommandClassID(", cc.Key, "),\n",
		"\t\tCommand: cc.CommandID(", cmd.Key, "),\n",
		"\t\tVersion: ", strconv.Itoa(cc.Version), ",\n",
		"\t}, New", structName, ")\n",
		"}\n\n",
		"func New", structName, "() cc.Command {\n",
		"\treturn &", structName, "{}\n",
		"}\n\n",
		"// <no value>\n",
		"type ", structName, " struct {\n",
	)
	if err != nil {
		return
	}
	for _, p := range cmd.Params {
		if !p.IsNotReserved() {
			continue
		}
		pname := toGoName(p.Name)
		switch p.Type {
		case "STRUCT_BYTE":
			_, err = writeStrings(w, "\t", pname, " struct {\n")
			if err != nil {
				return
			}
			for _, v := range p.BitField {
				if v.IsNotReserved() {
					fname := toGoName(v.FieldName)
					_, err = writeStrings(w, "\t\t", fname, " byte\n")
					if err != nil {
						return
					}
				}
			}
			for _, v := range p.BitFlag {
				if v.IsNotReserved() {
					fname := toGoName(v.FlagName)
					_, err = writeStrings(w, "\t\t", fname, " bool\n")
					if err != nil {
						return
					}
				}
			}
			for _, v := range p.FieldEnum {
				if v.IsNotReserved() {
					fname := toGoName(v.FieldName)
					_, err = writeStrings(w, "\t\t", fname, " byte\n")
					if err != nil {
						return
					}
				}
			}
			_, err = io.WriteString(w, "\t}\n")
			if err != nil {
				return
			}
		case "MARKER":
			break
		default:
			typ, _ := p.GetGoType()
			_, err = writeStrings(w, "\t", pname, " ", typ, "\n")
			if err != nil {
				return
			}
		}
	}

	_, err = writeStrings(w,
		"}\n\n",
		"func (cmd ", structName, ") CommandClassID() cc.CommandClassID {\n",
		"\treturn ", cc.Key, "\n",
		"}\n\n",
		"func (cmd ", structName, ") CommandID() cc.CommandID {\n",
		"\treturn Command", structName, "\n",
		"}\n\n",
		"func (cmd ", structName, ") CommandIDString() string {\n",
		"\treturn \"", cmd.Name, "\"\n",
		"}\n\n",
		"func (cmd *", structName, ") UnmarshalBinary(data []byte) error {\n",
		"\t// According to the docs, we must copy data if we wish to retain it after returning\n",
	)
	if err != nil {
		return
	}
	if len(cmd.Params) > 0 {
		_, err = writeStrings(w,
			"\tpayload := make([]byte, len(data))\n",
			"\tcopy(payload, data)\n",
			"\tif len(payload) < 2 {\n",
			"\t\treturn errors.New(\"Payload length underflow\")\n",
			"\t}\n",
			"\ti := 2\n",
		)
		if err != nil {
			return
		}
		for _, p := range cmd.Params {
			pname := toGoName(p.Name)
			switch p.Type {
			case "VARIANT":
				variant := p.Variant[0]
				if variant.MarkerDelimited {
					_, err = writeStrings(w,
						"\tif len(payload) <= i {\n",
						"\t\treturn errors.New(\"slice index out of bounds\")\n",
						"\t}\n",
						"\t{\n",
						"\t\tfieldStart := i\n",
						"\t\tfor ; i < len(payload) && payload[i] != ", variant.MarkerValue, "; i++ {\n",
						"\t\t}\n",
						"\t\tcmd.", pname, " = payload[fieldStart:i]\n",
						"\t}\n",
					)
					if err != nil {
						return
					}
				} else if variant.ParamOffset != 255 {
					_, err = writeStrings(w,
						"\tif len(payload) <= i {\n",
						"\t\treturn errors.New(\"slice index out of bounds\")\n",
						"\t}\n",
						"\t{\n",
						"\t\tlength := (payload[", strconv.Itoa(int(variant.ParamOffset)), "+2]",
					)
					if err != nil {
						return
					}
					if len(variant.SizeOffset) > 0 {
						_, err = writeStrings(w, " >> ", variant.SizeOffset)
						if err != nil {
							return
						}
					}
					io.WriteString(w, ")")
					if len(variant.SizeMask) > 0 {
						_, err = writeStrings(w, " & ", variant.SizeMask)
						if err != nil {
							return
						}
					}
					_, err = writeStrings(w,
						"\n",
						"\t\tcmd.", pname, " = payload[i : i+int(length)]\n",
						"\t\ti += int(length)\n",
						"\t}\n",
					)
					if err != nil {
						return
					}
				} else if variant.RemainingBytes > 0 {
					_, err = writeStrings(w,
						"\tif len(payload) <= i {\n",
						"\t\treturn errors.New(\"slice index out of bounds\")\n",
						"\t}\n",
						"\tcmd.", pname, " = payload[i : len(payload)-", strconv.Itoa(int(variant.RemainingBytes)), "]\n",
						"\ti += len(cmd.", pname, ")\n",
					)
					if err != nil {
						return
					}
				} else {
					_, err = writeStrings(w,
						"\tif len(payload) <= i {\n",
						"\t\treturn nil\n",
						"\t}\n",
						"\tcmd.", pname, " = payload[i:]\n",
					)
					if err != nil {
						return
					}
				}
			case "STRUCT_BYTE":
				_, err = writeStrings(w,
					"\tif len(payload) <= i {\n",
					"\t\treturn errors.New(\"slice index out of bounds\")\n",
					"\t}\n",
				)
				if err != nil {
					return
				}
				for _, v := range p.BitField {
					if v.IsNotReserved() {
						str := make([]string, 0, 11)
						str = append(str, "\tcmd.", pname, ".", toGoName(v.FieldName), " = (payload[i]")
						if len(v.FieldMask) > 0 {
							str = append(str, " & ", v.FieldMask)
						}
						str = append(str, ")")
						if v.Shifter > 0 {
							str = append(str, " >> ", strconv.Itoa(int(v.Shifter)))
						}
						str = append(str, "\n")
						if _, err = writeStrings(w, str...); err != nil {
							return
						}
					}
				}
				for _, v := range p.FieldEnum {
					str := make([]string, 0, 11)
					str = append(str, "\tcmd.", pname, ".", toGoName(v.FieldName), " = (payload[i]")
					if len(v.FieldMask) > 0 {
						str = append(str, " & ", v.FieldMask)
					}
					str = append(str, ")")
					if v.Shifter > 0 {
						str = append(str, " >> ", strconv.Itoa(int(v.Shifter)))
					}
					str = append(str, "\n")
					if _, err = writeStrings(w, str...); err != nil {
						return
					}
				}
				for _, v := range p.BitFlag {
					if v.IsNotReserved() {
						_, err = writeStrings(w,
							"\tcmd.", pname, ".", toGoName(v.FlagName), " = payload[i]&", v.FlagMask, " == ", v.FlagMask, "\n",
						)
						if err != nil {
							return
						}
					}
				}
				_, err = io.WriteString(w, "\ti += 1\n")
				if err != nil {
					return
				}
			case "ARRAY":
				_, err = writeStrings(w,
					"\tif len(payload) <= i {\n",
					"\t\treturn errors.New(\"slice index out of bounds\")\n",
					"\t}\n",
				)
				if err != nil {
					return
				}
				attr := p.ArrayAttrib[0]
				length := strconv.Itoa(attr.Length)
				if attr.IsAscii {
					_, err = writeStrings(w, "\tcmd.", pname, " = string(payload[i : i+", length, "])\n")
				} else {
					_, err = writeStrings(w, "\tcmd.", pname, " = payload[i : i+", length, "]\n")
				}
				if err != nil {
					return
				}
				_, err = writeStrings(w, "\ti += ", length, "\n")
				if err != nil {
					return
				}
			case "BITMASK":
				_, err = writeStrings(w,
					"\tif len(payload) <= i {\n",
					"\t\treturn errors.New(\"slice index out of bounds\")\n",
					"\t}\n",
					"\tcmd.", pname, " = payload[i:]\n",
				)
				if err != nil {
					return
				}
			case "DWORD":
				_, err = writeStrings(w,
					"\tif len(payload) <= i {\n",
					"\t\treturn errors.New(\"slice index out of bounds\")\n",
					"\t}\n",
					"\tcmd.", pname, " = binary.BigEndian.Uint32(payload[i : i+4])\n",
					"\ti += 4\n",
				)
				if err != nil {
					return
				}
			case "BIT_24":
				_, err = writeStrings(w,
					"\tif len(payload) <= i {\n",
					"\t\treturn errors.New(\"slice index out of bounds\")\n",
					"\t}\n",
					"\tcmd.", pname, " = binary.BigEndian.Uint32(payload[i : i+3])\n",
					"\ti += 3\n",
				)
				if err != nil {
					return
				}
			case "WORD":
				_, err = writeStrings(w,
					"\tif len(payload) <= i {\n",
					"\t\treturn errors.New(\"slice index out of bounds\")\n",
					"\t}\n",
					"\tcmd.", pname, " = binary.BigEndian.Uint16(payload[i : i+2])\n",
					"\ti += 2\n",
				)
				if err != nil {
					return
				}
			case "MARKER":
				_, err = writeStrings(w,
					"\tif len(payload) <= i {\n",
					"\t\treturn errors.New(\"slice index out of bounds\")\n",
					"\t}\n",
					"\ti += 1 // skipping MARKER\n",
					"\tif len(payload) <= i {\n",
					"\t\treturn nil\n",
					"\t}\n",
				)
				if err != nil {
					return
				}
			default:
				_, err = writeStrings(w,
					"\tif len(payload) <= i {\n",
					"\t\treturn errors.New(\"slice index out of bounds\")\n",
					"\t}\n",
				)
				if err != nil {
					return
				}
				if p.IsNotReserved() {
					_, err = writeStrings(w,
						"\tcmd.", pname, " = payload[i]\n",
						"\ti++\n",
					)
				}
			}
		}
	}
	_, err = writeStrings(w,
		"\treturn nil\n",
		"}\n\n",
		"func (cmd *", structName, ") MarshalBinary() (payload []byte, err error) {\n",
		"\tpayload = make([]byte, 2)\n",
		"\tpayload[0] = byte(cmd.CommandClassID())\n",
		"\tpayload[1] = byte(cmd.CommandID())\n",
	)
	if err != nil {
		return
	}
	for _, p := range cmd.Params {
		pname := toGoName(p.Name)
		switch p.Type {
		case "VARIANT":
			variant := p.Variant[0]
			if variant.ParamOffset == 255 {
				if variant.MarkerDelimited {
					_, err = writeStrings(w,
						"\t{\n",
						"\t\tif cmd.", pname, " != nil && len(cmd.", pname, ") > 0 {\n",
						"\t\t\tpayload = append(payload, cmd.", pname, "...)\n",
						"\t\t}\n",
						"\t\tpayload = append(payload, ", variant.MarkerValue, ")\n",
						"\t}\n",
					)
					if err != nil {
						return
					}
				} else {
					_, err = writeStrings(w,
						"\tpayload = append(payload, cmd.", pname, "...)\n",
					)
					if err != nil {
						return
					}
				}
			} else {
				_, err = writeStrings(w,
					"\tif cmd.", pname, " != nil && len(cmd.", pname, ") > 0 {\n",
					"\t\tpayload = append(payload, cmd.", pname, "...)\n",
					"\t}\n",
				)
				if err != nil {
					return
				}
			}
		case "STRUCT_BYTE":
			_, err = writeStrings(w,
				"\t{\n",
				"\t\tvar val byte\n",
			)
			if err != nil {
				return
			}
			for _, v := range p.BitField {
				if v.IsNotReserved() {
					str := make([]string, 0, 12)
					str = append(str, "\t\tval |= (cmd.", pname, ".", toGoName(v.FieldName))
					if v.Shifter > 0 {
						str = append(str, " << byte(", strconv.Itoa(int(v.Shifter)), ")")
					}
					str = append(str, ")")
					if len(v.FieldMask) > 0 {
						str = append(str, " & byte(", v.FieldMask, ")")
					}
					str = append(str, "\n")
					if _, err = writeStrings(w, str...); err != nil {
						return
					}
				}
			}
			for _, v := range p.FieldEnum {
				str := make([]string, 0, 12)
				str = append(str, "\t\tval |= (cmd.", pname, ".", toGoName(v.FieldName))
				if v.Shifter > 0 {
					str = append(str, " << byte(", strconv.Itoa(int(v.Shifter)), ")")
				}
				str = append(str, ")")
				if len(v.FieldMask) > 0 {
					str = append(str, " & byte(", v.FieldMask, ")")
				}
				str = append(str, "\n")
				if _, err = writeStrings(w, str...); err != nil {
					return
				}
			}
			for _, v := range p.BitFlag {
				if v.IsNotReserved() {
					_, err = writeStrings(w,
						"\t\tif cmd.", pname, ".", toGoName(v.FlagName), " {\n",
						"\t\t\tval |= byte(", v.FlagMask, ") // flip bits on\n",
						"\t\t} else {\n",
						"\t\t\tval &= ^byte(", v.FlagMask, ") // flip bits off\n",
						"\t\t}\n",
					)
					if err != nil {
						return
					}
				}
			}
			_, err = writeStrings(w,
				"\t\tpayload = append(payload, val)\n",
				"\t}\n",
			)
			if err != nil {
				return
			}
		case "ARRAY":
			attr := p.ArrayAttrib[0]
			length := strconv.Itoa(attr.Length)
			_, err = writeStrings(w,
				"\tif paramLen := len(cmd.", pname, "); paramLen > ", length, " {\n",
				"\t\treturn nil, errors.New(\"Length overflow in array parameter ", pname, "\")\n",
				"\t}\n",
			)
			if err != nil {
				return
			}
			if attr.IsAscii {
				_, err = writeStrings(w, "\tpayload = append(payload, []byte(cmd.", pname, ")...)\n")
			} else {
				_, err = writeStrings(w, "\tpayload = append(payload, cmd.", pname, "...)\n")
			}
			if err != nil {
				return
			}
		case "BITMASK":
			_, err = writeStrings(w,
				"\tpayload = append(payload, cmd.", pname, "...)\n",
			)
			if err != nil {
				return
			}
		case "DWORD":
			_, err = writeStrings(w,
				"\t{\n",
				"\t\tbuf := make([]byte, 4)\n",
				"\t\tbinary.BigEndian.PutUint32(buf, cmd.", pname, ")\n",
				"\t\tpayload = append(payload, buf...)\n",
				"\t}\n",
			)
			if err != nil {
				return
			}
		case "BIT_24":
			_, err = writeStrings(w,
				"\t{\n",
				"\t\tbuf := make([]byte, 4)\n",
				"\t\tbinary.BigEndian.PutUint32(buf, cmd.", pname, ")\n",
				"\t\tif buf[0] != 0 {\n",
				"\t\t\treturn nil, errors.New(\"BIT_24 value overflow\")\n",
				"\t\t}\n",
				"\t\tpayload = append(payload, buf[1:4]...)\n",
				"\t}\n",
			)
			if err != nil {
				return
			}
		case "WORD":
			_, err = writeStrings(w,
				"\t{\n",
				"\t\tbuf := make([]byte, 2)\n",
				"\t\tbinary.BigEndian.PutUint16(buf, cmd.", pname, ")\n",
				"\t\tpayload = append(payload, buf...)\n",
				"\t}\n",
			)
			if err != nil {
				return
			}
		case "MARKER":
			_, err = writeStrings(w,
				"\tpayload = append(payload, ", p.Const[0].FlagMask, ") // marker\n",
			)
			if err != nil {
				return
			}
		default:
			if p.IsNotReserved() {
				_, err = writeStrings(w,
					"\tpayload = append(payload, cmd.", pname, ")\n",
				)
				if err != nil {
					return
				}
			}
		}
	}

	io.WriteString(w, "\treturn\n")
	_, err = io.WriteString(w, "}\n")
	return
}
