// THIS FILE IS AUTO-GENERATED BY CCGEN
// DO NOT MODIFY

package chimneyfan

import "errors"

// <no value>

type ChimneyFanAlarmLogReport struct {
	AlarmEvent1 struct {
		ExternalAlarm1 bool

		SensorError1 bool

		AlarmTemperatureExceeded1 bool

		AlarmStillActive1 bool
	}

	AlarmEvent2 struct {
		ExternalAlarm2 bool

		SensorError2 bool

		AlarmTemperatureExceeded2 bool

		AlarmStillActive2 bool
	}

	AlarmEvent3 struct {
		ExternalAlarm3 bool

		SensorError3 bool

		AlarmTemperatureExceeded3 bool

		AlarmStillActive3 bool
	}

	AlarmEvent4 struct {
		ExternalAlarm4 bool

		SensorError4 bool

		AlarmTemperatureExceeded4 bool

		AlarmStillActive4 bool
	}

	AlarmEvent5 struct {
		ExternalAlarm5 bool

		SensorError5 bool

		AlarmTemperatureExceeded5 bool

		AlarmStillActive5 bool
	}
}

func (cmd *ChimneyFanAlarmLogReport) UnmarshalBinary(payload []byte) error {
	i := 0

	if len(payload) <= i {
		return errors.New("slice index out of bounds")
	}

	if payload[i]&0x02 == 0x02 {
		cmd.AlarmEvent1.ExternalAlarm1 = true
	} else {
		cmd.AlarmEvent1.ExternalAlarm1 = false
	}

	if payload[i]&0x04 == 0x04 {
		cmd.AlarmEvent1.SensorError1 = true
	} else {
		cmd.AlarmEvent1.SensorError1 = false
	}

	if payload[i]&0x08 == 0x08 {
		cmd.AlarmEvent1.AlarmTemperatureExceeded1 = true
	} else {
		cmd.AlarmEvent1.AlarmTemperatureExceeded1 = false
	}

	if payload[i]&0x80 == 0x80 {
		cmd.AlarmEvent1.AlarmStillActive1 = true
	} else {
		cmd.AlarmEvent1.AlarmStillActive1 = false
	}

	i += 1

	if len(payload) <= i {
		return errors.New("slice index out of bounds")
	}

	if payload[i]&0x02 == 0x02 {
		cmd.AlarmEvent2.ExternalAlarm2 = true
	} else {
		cmd.AlarmEvent2.ExternalAlarm2 = false
	}

	if payload[i]&0x04 == 0x04 {
		cmd.AlarmEvent2.SensorError2 = true
	} else {
		cmd.AlarmEvent2.SensorError2 = false
	}

	if payload[i]&0x08 == 0x08 {
		cmd.AlarmEvent2.AlarmTemperatureExceeded2 = true
	} else {
		cmd.AlarmEvent2.AlarmTemperatureExceeded2 = false
	}

	if payload[i]&0x80 == 0x80 {
		cmd.AlarmEvent2.AlarmStillActive2 = true
	} else {
		cmd.AlarmEvent2.AlarmStillActive2 = false
	}

	i += 1

	if len(payload) <= i {
		return errors.New("slice index out of bounds")
	}

	if payload[i]&0x02 == 0x02 {
		cmd.AlarmEvent3.ExternalAlarm3 = true
	} else {
		cmd.AlarmEvent3.ExternalAlarm3 = false
	}

	if payload[i]&0x04 == 0x04 {
		cmd.AlarmEvent3.SensorError3 = true
	} else {
		cmd.AlarmEvent3.SensorError3 = false
	}

	if payload[i]&0x08 == 0x08 {
		cmd.AlarmEvent3.AlarmTemperatureExceeded3 = true
	} else {
		cmd.AlarmEvent3.AlarmTemperatureExceeded3 = false
	}

	if payload[i]&0x80 == 0x80 {
		cmd.AlarmEvent3.AlarmStillActive3 = true
	} else {
		cmd.AlarmEvent3.AlarmStillActive3 = false
	}

	i += 1

	if len(payload) <= i {
		return errors.New("slice index out of bounds")
	}

	if payload[i]&0x02 == 0x02 {
		cmd.AlarmEvent4.ExternalAlarm4 = true
	} else {
		cmd.AlarmEvent4.ExternalAlarm4 = false
	}

	if payload[i]&0x04 == 0x04 {
		cmd.AlarmEvent4.SensorError4 = true
	} else {
		cmd.AlarmEvent4.SensorError4 = false
	}

	if payload[i]&0x08 == 0x08 {
		cmd.AlarmEvent4.AlarmTemperatureExceeded4 = true
	} else {
		cmd.AlarmEvent4.AlarmTemperatureExceeded4 = false
	}

	if payload[i]&0x80 == 0x80 {
		cmd.AlarmEvent4.AlarmStillActive4 = true
	} else {
		cmd.AlarmEvent4.AlarmStillActive4 = false
	}

	i += 1

	if len(payload) <= i {
		return errors.New("slice index out of bounds")
	}

	if payload[i]&0x02 == 0x02 {
		cmd.AlarmEvent5.ExternalAlarm5 = true
	} else {
		cmd.AlarmEvent5.ExternalAlarm5 = false
	}

	if payload[i]&0x04 == 0x04 {
		cmd.AlarmEvent5.SensorError5 = true
	} else {
		cmd.AlarmEvent5.SensorError5 = false
	}

	if payload[i]&0x08 == 0x08 {
		cmd.AlarmEvent5.AlarmTemperatureExceeded5 = true
	} else {
		cmd.AlarmEvent5.AlarmTemperatureExceeded5 = false
	}

	if payload[i]&0x80 == 0x80 {
		cmd.AlarmEvent5.AlarmStillActive5 = true
	} else {
		cmd.AlarmEvent5.AlarmStillActive5 = false
	}

	i += 1

	return nil
}

func (cmd *ChimneyFanAlarmLogReport) MarshalBinary() (payload []byte, err error) {

	{
		var val byte

		if cmd.AlarmEvent1.ExternalAlarm1 {
			val |= byte(0x02) // flip bits on
		} else {
			val &= ^byte(0x02) // flip bits off
		}

		if cmd.AlarmEvent1.SensorError1 {
			val |= byte(0x04) // flip bits on
		} else {
			val &= ^byte(0x04) // flip bits off
		}

		if cmd.AlarmEvent1.AlarmTemperatureExceeded1 {
			val |= byte(0x08) // flip bits on
		} else {
			val &= ^byte(0x08) // flip bits off
		}

		if cmd.AlarmEvent1.AlarmStillActive1 {
			val |= byte(0x80) // flip bits on
		} else {
			val &= ^byte(0x80) // flip bits off
		}

		payload = append(payload, val)
	}

	{
		var val byte

		if cmd.AlarmEvent2.ExternalAlarm2 {
			val |= byte(0x02) // flip bits on
		} else {
			val &= ^byte(0x02) // flip bits off
		}

		if cmd.AlarmEvent2.SensorError2 {
			val |= byte(0x04) // flip bits on
		} else {
			val &= ^byte(0x04) // flip bits off
		}

		if cmd.AlarmEvent2.AlarmTemperatureExceeded2 {
			val |= byte(0x08) // flip bits on
		} else {
			val &= ^byte(0x08) // flip bits off
		}

		if cmd.AlarmEvent2.AlarmStillActive2 {
			val |= byte(0x80) // flip bits on
		} else {
			val &= ^byte(0x80) // flip bits off
		}

		payload = append(payload, val)
	}

	{
		var val byte

		if cmd.AlarmEvent3.ExternalAlarm3 {
			val |= byte(0x02) // flip bits on
		} else {
			val &= ^byte(0x02) // flip bits off
		}

		if cmd.AlarmEvent3.SensorError3 {
			val |= byte(0x04) // flip bits on
		} else {
			val &= ^byte(0x04) // flip bits off
		}

		if cmd.AlarmEvent3.AlarmTemperatureExceeded3 {
			val |= byte(0x08) // flip bits on
		} else {
			val &= ^byte(0x08) // flip bits off
		}

		if cmd.AlarmEvent3.AlarmStillActive3 {
			val |= byte(0x80) // flip bits on
		} else {
			val &= ^byte(0x80) // flip bits off
		}

		payload = append(payload, val)
	}

	{
		var val byte

		if cmd.AlarmEvent4.ExternalAlarm4 {
			val |= byte(0x02) // flip bits on
		} else {
			val &= ^byte(0x02) // flip bits off
		}

		if cmd.AlarmEvent4.SensorError4 {
			val |= byte(0x04) // flip bits on
		} else {
			val &= ^byte(0x04) // flip bits off
		}

		if cmd.AlarmEvent4.AlarmTemperatureExceeded4 {
			val |= byte(0x08) // flip bits on
		} else {
			val &= ^byte(0x08) // flip bits off
		}

		if cmd.AlarmEvent4.AlarmStillActive4 {
			val |= byte(0x80) // flip bits on
		} else {
			val &= ^byte(0x80) // flip bits off
		}

		payload = append(payload, val)
	}

	{
		var val byte

		if cmd.AlarmEvent5.ExternalAlarm5 {
			val |= byte(0x02) // flip bits on
		} else {
			val &= ^byte(0x02) // flip bits off
		}

		if cmd.AlarmEvent5.SensorError5 {
			val |= byte(0x04) // flip bits on
		} else {
			val &= ^byte(0x04) // flip bits off
		}

		if cmd.AlarmEvent5.AlarmTemperatureExceeded5 {
			val |= byte(0x08) // flip bits on
		} else {
			val &= ^byte(0x08) // flip bits off
		}

		if cmd.AlarmEvent5.AlarmStillActive5 {
			val |= byte(0x80) // flip bits on
		} else {
			val &= ^byte(0x80) // flip bits off
		}

		payload = append(payload, val)
	}

	return
}
